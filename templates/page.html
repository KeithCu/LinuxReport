<!doctype html>
<html lang="en">
  <head>
    <link rel="icon" type="image/png" href="{{favicon}}">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content = "{{description}}">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>{{title}}</title>
    <style>
      /* Theme definitions */
      body.theme-light { --bg:#ffffff; --text:#000000; --link:#1a0dab; --btn-bg:#f6f6f6; --btn-border:#092236; --btn-text:#3b5971; --btn-hover-bg:#0078D7; --btn-hover-text:#ffffff; }
      body.theme-silver  { --bg:#C0C0C0; --text:#000000; --link:#1a0dab; --btn-bg:#EFEFEF; --btn-border:#888888; --btn-text:#000000; --btn-hover-bg:#C0C0C0; --btn-hover-text:#FFFFFF; }
      body.theme-dark { --bg:#1e1e1e; --text:#f0f0f0; --link:#8ab4f8; --btn-bg:#333333; --btn-border:#ffffff; --btn-text:#ffffff; --btn-hover-bg:#505050; --btn-hover-text:#ffffff; }
      body.theme-solarized { --bg:#fdf6e3; --text:#657b83; --link:#268bd2; --btn-bg:#eee8d5; --btn-border:#586e75; --btn-text:#586e75; --btn-hover-bg:#b58900; --btn-hover-text:#fdf6e3; }

      /* New custom themes */
      body.theme-futuristic { --bg:#0f0f0f; --text:rgb(49, 165, 165); --link:#0f0; --btn-bg:#111; --btn-border:#0ff; --btn-text:#0ff; --btn-hover-bg:#0f0; --btn-hover-text:#000; }
      body.theme-steampunk { --bg:#2b1b0e; --text:#d5c1a1; --link:#a67c52; --btn-bg:#3e2c1c; --btn-border:#a67c52; --btn-text:#d5c1a1; --btn-hover-bg:#a67c52; --btn-hover-text:#2b1b0e; }
      body.theme-cyberpunk { --bg:#1e001f; --text:#a027a0; --link:#00ffff; --btn-bg:#330033; --btn-border:#ff00ff; --btn-text:#ff00ff; --btn-hover-bg:#00ffff; --btn-hover-text:#1e001f; }

      /* Additional custom themes */
      body.theme-pastelle{ --bg:#FFEFD5; --text:#4B3621; --link:#FFB6C1; --btn-bg:#FFDAB9; --btn-border:#DEB887; --btn-text:#4B3621; --btn-hover-bg:#FFA07A; --btn-hover-text:#FFFFFF; }
      body.theme-sepia   { --bg:#704214; --text:#FFF8E7; --link:#B8860B; --btn-bg:#C19A6B; --btn-border:#8B4513; --btn-text:#FFF8E7; --btn-hover-bg:#8B4513; --btn-hover-text:#FFF8E7; }
      body.theme-forest  { --bg:#2E4A2E; --text:#E0EBD8; --link:#A3B18A; --btn-bg:#4A6F4A; --btn-border:#A3B18A; --btn-text:#E0EBD8; --btn-hover-bg:#A3B18A; --btn-hover-text:#2E4A2E; }

      /* Client-side dynamic sans-serif font */
      body.sans-serif { font-family: sans-serif; }

      /* Force sans-serif font everywhere when enabled */
      body.sans-serif, body.sans-serif * {
        font-family: sans-serif !important;
      }

      * {
        box-sizing: border-box;
      }

      body {
        color: var(--text);
        background-color: var(--bg);
      }

      /* Default link style: color and no underline */
      a:link, a:visited, a:hover, a:active {
        color: var(--link);
        text-decoration: none;
      }

      /* Ensure code elements use inherited font */
      code {
        font-family: inherit !important;
      }

      /* Override entry link color and remove underline */
      .linkclass a {
        color: var(--text) !important;
        text-decoration: none !important;
      }
      .linkclass a:hover, .linkclass a:visited, .linkclass a:active {
        color: var(--text) !important;
        text-decoration: none !important;
      }

      img {
        max-width: 100%;
      }

      .linkclass {
        margin-bottom: .6em;
        font-size: large
      }

      /* Client-side dynamic link underlines */
      body.no-underlines a { text-decoration: none; }

      /* Ensure link underlines are removed everywhere when enabled */
      body.no-underlines a, body.no-underlines a * {
        text-decoration: none !important;
      }

      {%- if not g.is_mobile %}
      /* Create three equal columns that floats next to each other */
      .column {
        float: left;
        width: 33.33%;
        padding: 10px;
      }

      .image-container {
        width: 100%;
      }

      .image-container img {
        width: 100%;
        height: auto;
        display: block;
      }

      .title-container {
        margin-top: 10px;
      }
      /* Clear floats after the columns */
      .row:after {
        content: "";
        display: table;
        clear: both;
      }
      {%- endif %}

      /* Override nav links for mobile: larger tap targets, spacing, block display */
      {%- if g.is_mobile %}
      .nav-links-mobile a {
        display: block;
        font-size: 1.3em;
        padding: 14px 0 14px 0;
        margin: 6px 0;
        min-width: 44px;
        min-height: 44px;
        text-align: center;
        border-radius: 8px;
        background: var(--btn-bg);
        color: var(--link) !important;
      }
      .nav-links-mobile a:active, .nav-links-mobile a:focus {
        background: var(--btn-hover-bg);
        color: var(--btn-hover-text) !important;
      }
      {%- endif %}

      .pagination-controls {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 10px;
        margin: 10px 0;
      }

      .pagination-controls button {
        padding: 5px 15px;
        border: 2px solid var(--btn-border);
        border-radius: 5px;
        background-color: var(--btn-bg);
        color: var(--btn-text);
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        transition: background-color 0.3s ease, color 0.3s ease, transform 0.2s ease;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .pagination-controls button:hover:not(:disabled) {
        background-color: var(--btn-hover-bg);
        color: var(--btn-hover-text);
        transform: scale(1.05);
        box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
      }

      .pagination-controls button:disabled {
        background-color: #e0e0e0;
        color: #a0a0a0;
        cursor: not-allowed;
      }

      /* Old Headlines link styling */
      #old-headlines-link {
        position: relative;
        padding: 8px 15px;
        border-radius: 5px;
        font-weight: bold;
        transition: all 0.3s ease;
        animation: pulse 3s infinite;
        background: var(--btn-bg);
        border: 2px solid var(--btn-border);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      #old-headlines-link:hover {
        transform: scale(1.05);
        background: var(--btn-hover-bg);
        color: var(--btn-hover-text) !important;
        box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        50% {
          transform: scale(1.02);
          box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
        }
        100% {
          transform: scale(1);
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
      }

    .weather-container {
      max-width: 100%;
      margin: 10px auto;
      padding: 10px;
      background-color: var(--btn-bg);
      color: var(--text);
      border-radius: 8px;
      text-align: center;
    }
  
    .weather-container h3 {
      margin-top: 0;
      margin-bottom: 10px;
    }
  
    .weather-forecast {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
    }
  
    .weather-day {
      flex: 1;
      min-width: 80px;
      margin: 5px;
      padding: 8px;
      background-color: var(--btn-bg);
      border: 1px solid var(--btn-border);
      border-radius: 5px;
    }
  
    .weather-day-name {
      font-weight: bold;
      margin-bottom: 5px;
    }
  
    .weather-icon {
      width: 40px;
      height: 40px;
    }
  
    .weather-temp {
      margin: 5px 0;
    }
  
    .weather-precip {
      font-size: 0.9em;
      color: var(--link);
    }
  
    /* Remove static dark-mode overrides; variables handle all themes */

    /* Override monospace in entry titles and use inherited font */
    .linkclass code {
      font-family: inherit !important;
    }

      /* Chat Window Styles */
      #chat-container {
        position: fixed;
        top: 20px; /* Changed from bottom */
        bottom: 20px; /* Added to stretch */
        right: 20px;
        width: 350px; /* Kept width */
        /* height: 400px; Removed height */
        background-color: var(--bg);
        border: 2px solid var(--btn-border);
        border-radius: 8px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        display: none; /* Hidden by default */
        flex-direction: column;
        overflow: hidden; /* Needed for resize handle */
        z-index: 1000; /* Ensure it's on top */
        resize: both; /* Allow resizing - might conflict slightly with top/bottom */
        min-width: 250px; /* Min size */
        min-height: 200px; /* Min size */
      }

      #chat-header {
        padding: 8px 12px;
        background-color: var(--btn-bg);
        color: var(--text);
        font-weight: bold;
        cursor: move; /* Indicate draggable */
        border-bottom: 1px solid var(--btn-border);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
       #chat-header button {
         background: none;
         border: none;
         color: var(--text);
         font-size: 1.2em;
         cursor: pointer;
       }

      #chat-messages {
        flex-grow: 1;
        overflow-y: auto;
        padding: 10px;
        border-bottom: 1px solid var(--btn-border);
        display: flex;
        flex-direction: column-reverse; /* Newest messages at the bottom */
      }

      .chat-message {
        margin-bottom: 8px;
        padding: 6px 10px;
        border-radius: 5px;
        background-color: var(--btn-bg);
        word-wrap: break-word;
      }
      .chat-message img {
         max-width: 100%;
         max-height: 150px; /* Limit image preview size */
         display: block;
         margin-top: 5px;
         border-radius: 4px;
      }
      .chat-message .timestamp {
         font-size: 0.7em;
         color: var(--link); /* Use link color for timestamp */
         display: block;
         margin-top: 4px;
      }

      #chat-input-area {
        padding: 10px;
        display: flex;
        gap: 5px;
      }

      #chat-input-area textarea {
        flex-grow: 1;
        padding: 8px;
        border: 1px solid var(--btn-border);
        border-radius: 4px;
        resize: none; /* Disable textarea's own resize handle */
        background-color: var(--bg);
        color: var(--text);
        min-height: 40px; /* Ensure decent initial height */
        max-height: 100px; /* Limit expansion */
        transition: border-color 0.3s ease; /* Add transition for dragover */
      }
       #chat-input-area input[type="text"] { /* For image URL */
         flex-grow: 1;
         padding: 8px;
         border: 1px solid var(--btn-border);
         border-radius: 4px;
         background-color: var(--bg);
         color: var(--text);
         margin-top: 5px; /* Space between text and image input */
       }
      /* Style for dragover state */
      #chat-input-area.dragover {
        border: 2px dashed var(--link);
        background-color: rgba(138, 180, 248, 0.1); /* Light background tint for dark/light themes */
      }

      #chat-input-area button {
        padding: 8px 15px;
        border: 1px solid var(--btn-border);
        border-radius: 4px;
        background-color: var(--btn-bg);
        color: var(--btn-text);
        cursor: pointer;
      }
      #chat-input-area button:hover {
         background-color: var(--btn-hover-bg);
         color: var(--btn-hover-text);
      }

      /* Chat Toggle Button Style (similar to old headlines) */
      #chat-toggle-btn {
        position: relative;
        padding: 8px 15px;
        border-radius: 5px;
        font-weight: bold;
        transition: all 0.3s ease;
        animation: pulse 3s infinite; /* Use the same pulse animation */
        background: var(--btn-bg);
        border: 2px solid var(--btn-border);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        color: var(--btn-text); /* Ensure button text color is set */
        cursor: pointer; /* Add cursor pointer */
        margin-left: 10px; /* Add some space */
      }

      #chat-toggle-btn:hover {
        transform: scale(1.05);
        background: var(--btn-hover-bg);
        color: var(--btn-hover-text) !important; /* Important to override potential link styles */
        box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
      }
    
  </style>
  <!-- Apply theme based on 'Theme' cookie and set dropdown selection -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Read theme cookie or default
      var match = document.cookie.match(/(?:^|; )Theme=([^;]+)/);
      var theme = match ? match[1] : 'light';
      // Apply theme class to body
      document.body.classList.add('theme-' + theme);
      // Set dropdown to current theme
      var select = document.getElementById('theme-select');
      if (select) select.value = theme;
      // Apply no-underlines setting (default ON)
      var nu = document.cookie.match(/(?:^|; )NoUnderlines=([^;]+)/);
      if (!nu || nu[1] === '1') document.body.classList.add('no-underlines');
      // Apply sans-serif setting (default ON)
      var ss = document.cookie.match(/(?:^|; )SansSerif=([^;]+)/);
      if (!ss || ss[1] === '1') document.body.classList.add('sans-serif');
    });
  </script>
  <script>
      function redirect() {
        window.location = "/config"
      }
      var timer = setInterval("autoRefresh()", 3601 * 1000);
        function autoRefresh(){self.location.reload();}
    </script>
    <script>
      // Change theme via cookie and reload
      function setTheme(theme) {
        document.cookie = 'Theme=' + theme + ';path=/';
        window.location.reload();
      }
    </script>
  </head>
  <body>

<div style="background: var(--btn-bg); color: var(--text); border: 2px solid var(--btn-border); border-radius: 8px; margin: 10px auto 0 auto; max-width: 700px; padding: 8px; font-size: .5em; text-align: center;">
  <strong>Message from Keith:</strong> Sorry! I fixed some bugs recently, it should be smooth sailing now.
</div>

<center>
  <div style="border: 1px solid var(--btn-border); padding: 5px; margin: 5px; display: inline-flex; align-items: center; font-size: small; position: relative;">
    <a href="https://openweathermap.org" target="_blank" style="text-decoration: none; color: inherit;">
      <center>{{ weather_html }}</center>
      <div style="position: absolute; bottom: 0; right: 0; font-size: 8px; color: var(--link);">Data by OpenWeather</div>
    </a>
  </div>
</center>
  
  <center>
    <div style="border: 2px solid var(--btn-border); padding: 5px; margin: 5px; display: inline-flex; align-items: center; font-size: large;">
      <div class="nav-links-mobile">
        <a href="https://linuxreport.net" target="_blank" style="margin: 2px; color: inherit;">Linux</a>
        <a href="https://covidreport.org" target="_blank" style="margin: 2px; color: inherit;">Covid</a>
        <a href="https://aireport.keithcu.com" target="_blank" style="margin: 2px; color: inherit;">AI</a>
        <a href="https://trumpreport.info" target="_blank" style="margin: 2px; color: inherit;">Truth</a>
        <a href="https://spaceelevatorwiki.com" target="_blank" style="margin: 2px; color: inherit;">Space-Soon</a>
        <a href="https://keithcu.com/wordpress/?page_id=407/" target="_blank" style="margin: 2px; color: inherit;">Me</a>
      </div>
      <select id="theme-select" onchange="setTheme(this.value)" style="margin-left:20px; padding:5px;">
        <option value="light">Light</option>
        <option value="dark">Dark</option>
        <option value="solarized">Solarized</option>
        <option value="futuristic">Futuristic</option>
        <option value="steampunk">Steampunk</option>
        <option value="cyberpunk">Cyberpunk</option>
        <option value="silver">Silver</option>
        <option value="pastelle">Pastelle</option>
        <option value="sepia">Sepia</option>
        <option value="forest">Forest</option>
      </select>
      <a href="/old_headlines" id="old-headlines-link" style="margin-left: 20px; padding: 5px; text-decoration: underline; color: var(--link); font-size: medium;">Old Headlines</a>
      <button id="chat-toggle-btn">Chat</button> <!-- Added Chat Toggle Button -->
      <button type="save" name="save" onclick="redirect()" style="margin-left: 20px;">Config...</button>
    </div>
  </center>

    <center>{{ above_html }}</center>
    <center><img src="{{logo_url}}" alt = "{{ title }}" style="max-height:250px;"></center>
    <center><small>{{ welcome_html }}</small></center>

    <div class="row">
      <div class="column">{{ columns[0] }}</div>
      {%- if not g.is_mobile %}
      <div class="column">{{ columns[1] }}</div>
      <div class="column">{{ columns[2] }}</div>
      {%- endif %}
    </div>

    <!-- Chat Window HTML -->
    <div id="chat-container">
      <div id="chat-header">
        <span>Visitor Chat</span>
        <button id="chat-close-btn" title="Close Chat">&times;</button>
      </div>
      <div id="chat-messages">
        <!-- Messages will be loaded here -->
        <div id="chat-loading" style="text-align: center; padding: 10px;">Loading messages...</div>
      </div>
      <div id="chat-input-area">
         <div style="display: flex; flex-direction: column; flex-grow: 1;">
             <textarea id="chat-message-input" placeholder="Type your message (use <b>text</b> for bold)" rows="2"></textarea>
             <input type="text" id="chat-image-url-input" placeholder="Optional: Image URL or base64">
         </div>
        <button id="chat-send-btn">Send</button>
      </div>
    </div>
  </body>
</html>
 
<script>
document.addEventListener("DOMContentLoaded", function () {
  const feeds = document.querySelectorAll(".pagination-controls");

  feeds.forEach(feedControls => {
    const feedId = feedControls.dataset.feedId;
    const feedContainer = document.getElementById(feedId);

    if (!feedContainer) {
      console.error(`Feed container with ID "${feedId}" not found.`);
      return; // Skip this feed if the container is missing
    }

    const items = feedContainer.querySelectorAll(".linkclass");
    const prevBtn = feedControls.querySelector(".prev-btn");
    const nextBtn = feedControls.querySelector(".next-btn");

    if (items.length === 0) {
      console.warn(`No items found for feed "${feedId}".`);
      prevBtn.disabled = true;
      nextBtn.disabled = true;
      return;
    }

    const itemsPerPage = 8; // Entries per page
    let currentPage = 0;
    const totalItems = items.length;
    const totalPages = Math.ceil(totalItems / itemsPerPage);

    function updatePagination() {
      const start = currentPage * itemsPerPage;
      const end = start + itemsPerPage;

      items.forEach((item, index) => {
        item.style.display = index >= start && index < end ? "block" : "none";
      });

      prevBtn.disabled = currentPage === 0;
      nextBtn.disabled = currentPage >= totalPages - 1;
    }

    prevBtn.addEventListener("click", () => {
      if (currentPage > 0) {
        currentPage--;
        updatePagination();
      }
    });

    nextBtn.addEventListener("click", () => {
      if (currentPage < totalPages - 1) {
        currentPage++;
        updatePagination();
      }
    });

    // Initialize pagination for this feed
    updatePagination();
  });
});
</script>


<script>
  document.addEventListener("DOMContentLoaded", function() {
    // Weather functionality
    function loadWeather() {
      const weatherContainer = document.getElementById('weather-container');
      if (!weatherContainer) return;
      const weatherLoading = document.getElementById('weather-loading');
      const weatherError = document.getElementById('weather-error');
      const weatherForecast = document.getElementById('weather-forecast');
      fetchWeatherData();
    }
    function fetchWeatherData() {
      // Add cache-busting param using YYYYMMDDHH to avoid browser caching across days/hours
      const now = new Date();
      const year = now.getFullYear();
      const month = (now.getMonth() + 1).toString().padStart(2, '0'); // Months are 0-indexed
      const day = now.getDate().toString().padStart(2, '0');
      const hour = now.getHours().toString().padStart(2, '0');
      const cacheBuster = `${year}${month}${day}${hour}`;
      fetch(`/api/weather?_=${cacheBuster}`)
        .then(response => {
          if (!response.ok) throw new Error('Network response was not ok');
          return response.json();
        })
        .then(data => {
          renderWeatherData(data);
        })
        .catch(error => {
          document.getElementById('weather-loading').style.display = "none";
          document.getElementById('weather-error').style.display = "block";
        });
    }
    function renderWeatherData(data) {
      const weatherForecast = document.getElementById('weather-forecast');
      const weatherLoading = document.getElementById('weather-loading');
      const weatherError = document.getElementById('weather-error');
      if (!data.daily || data.daily.length === 0) {
        weatherLoading.style.display = "none";
        weatherError.style.display = "block";
        weatherError.textContent = "No weather data available.";
        return;
      }
      weatherForecast.innerHTML = '';
      weatherForecast.className = 'weather-forecast';
      const today = new Date();
      const todayYear = today.getFullYear();
      const todayMonth = today.getMonth();
      const todayDate = today.getDate();
      data.daily.forEach((day, i) => {
        const dayElement = document.createElement('div');
        dayElement.className = 'weather-day';
        const date = new Date(day.dt * 1000);
        const userLocale = navigator.language || 'en-US';
        let dayName;
        if (
          date.getFullYear() === todayYear &&
          date.getMonth() === todayMonth &&
          date.getDate() === todayDate
        ) {
          if (userLocale.startsWith('en')) {
            dayName = 'Today';
          } else {
            dayName = date.toLocaleDateString(userLocale, { weekday: 'long' });
          }
        } else {
          dayName = date.toLocaleDateString(userLocale, { weekday: 'short' });
        }
        dayElement.innerHTML = `
          <div class="weather-day-name">${dayName}</div>
          <img class="weather-icon" src="https://openweathermap.org/img/wn/${day.weather_icon}.png" alt="${day.weather}">
          <div class="weather-temp">
            <span class="temp-max">${Math.round(day.temp_max)}°</span> /
            <span class="temp-min">${Math.round(day.temp_min)}°</span>
          </div>
          <div class="weather-precip">${Math.round(day.precipitation)}% precip</div>
        `;
        weatherForecast.appendChild(dayElement);
      });
      weatherLoading.style.display = "none";
      weatherForecast.style.display = "flex";
    }
    setTimeout(loadWeather, 100);
  });
</script>

<!-- Chat Window JavaScript -->
<script>
  document.addEventListener('DOMContentLoaded', function() {
    const chatContainer = document.getElementById('chat-container');
    const chatHeader = document.getElementById('chat-header');
    const chatMessages = document.getElementById('chat-messages');
    const messageInput = document.getElementById('chat-message-input');
    const imageUrlInput = document.getElementById('chat-image-url-input');
    const sendButton = document.getElementById('chat-send-btn');
    const closeButton = document.getElementById('chat-close-btn');
    const loadingIndicator = document.getElementById('chat-loading');
    const chatToggleButton = document.getElementById('chat-toggle-btn'); // Get the toggle button
    const chatInputArea = document.getElementById('chat-input-area'); // Get input area for drag/drop

    // --- Configuration ---
    const useSSE = false; // <<< SET TO true TO ENABLE SSE, false FOR POLLING >>>
    const pollingInterval = 15000; // Poll every 15 seconds if SSE is disabled
    // ---------------------

    let isAdminMode = document.cookie.split('; ').some(item => item.trim().startsWith('isAdmin=1')); // Check for admin cookie
    let isDragging = false;
    let offsetX, offsetY;
    let lastComments = []; // Store last fetched comments to avoid duplicates
    let lastCommentTimestamp = null; // Store timestamp of the latest known comment
    const beepSound = new Audio('data:audio/wav;base64,UklGRlIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAAD//w=='); // Simple short beep
    let eventSource = null; // Variable to hold the EventSource instance for SSE
    let pollingTimer = null; // Variable to hold the polling interval timer

    // --- Draggable Window ---
    chatHeader.addEventListener('mousedown', (e) => {
      // Prevent dragging if clicking on the close button
      if (e.target === closeButton) return;
      isDragging = true;
      // Calculate offset from the top-left corner of the chat window
      offsetX = e.clientX - chatContainer.offsetLeft;
      offsetY = e.clientY - chatContainer.offsetTop;
      chatContainer.style.cursor = 'grabbing'; // Change cursor while dragging
      // Prevent text selection while dragging
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      // Calculate new position
      let newX = e.clientX - offsetX;
      let newY = e.clientY - offsetY;

      // Boundary checks (keep within viewport)
      const minX = 0;
      const minY = 0;
      const maxX = window.innerWidth - chatContainer.offsetWidth;
      const maxY = window.innerHeight - chatContainer.offsetHeight;

      newX = Math.max(minX, Math.min(newX, maxX));
      newY = Math.max(minY, Math.min(newY, maxY));

      chatContainer.style.left = newX + 'px';
      chatContainer.style.top = newY + 'px';
    });

    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        chatContainer.style.cursor = 'default'; // Reset cursor
      }
    });

    // --- Close Button ---
    closeButton.addEventListener('click', () => {
      chatContainer.style.display = 'none'; // Hide the chat window
      if (useSSE) closeSSE();
      if (!useSSE && pollingTimer) {
          console.log("Stopping polling timer.");
          clearInterval(pollingTimer);
          pollingTimer = null;
      }
    });

    // --- Toggle Button ---
    chatToggleButton.addEventListener('click', () => {
      const isHidden = chatContainer.style.display === 'none' || chatContainer.style.display === '';
      chatContainer.style.display = isHidden ? 'flex' : 'none'; // Toggle visibility
      if (isHidden) {
         // If opening the chat:
         if (useSSE) {
             initializeSSE(); // Start SSE if enabled
         } else {
             // Fetch comments immediately via polling if it was hidden and hasn't loaded yet
             if (lastComments.length === 0 && loadingIndicator.style.display !== 'none') {
                 fetchComments();
             }
             // Start polling if not already started
             if (!pollingTimer) {
                 console.log(`Starting polling timer. Interval: ${pollingInterval}ms`);
                 pollingTimer = setInterval(fetchComments, pollingInterval);
             }
         }
      } else {
          // If closing the chat:
          if (useSSE) closeSSE();
          if (!useSSE && pollingTimer) {
              console.log("Stopping polling timer via toggle.");
              clearInterval(pollingTimer);
              pollingTimer = null;
          }
      }
    });


    // --- Fetch Comments (Used for Polling) ---
    function fetchComments() {
      // *** Only fetch if chat is visible AND SSE is DISABLED ***
      if (useSSE || chatContainer.style.display === 'none') {
          // console.log("Skipping fetch: SSE enabled or Chat hidden.");
          return;
      }

      // Add cache-busting parameter with current timestamp (including seconds)
      const cacheBuster = new Date().getTime();
      console.log("Polling for comments..."); // Log polling action
      fetch(`/api/comments?_=${cacheBuster}`) // Append timestamp here
        .then(response => response.json())
        .then(comments => {
          loadingIndicator.style.display = 'none';
          renderComments(comments);
        })
        .catch(error => {
          console.error('Error fetching comments:', error);
          if (chatMessages.children.length <= 1) { // Only show if no messages are displayed
              loadingIndicator.textContent = 'Error loading messages.';
              loadingIndicator.style.display = 'block';
          }
        });
    }

    // --- Render Comments ---
    function renderComments(comments) {
       // console.log("renderComments received:", JSON.stringify(comments));

       // Determine if there are genuinely new messages since the last render (for beep)
       let newMessagesExist = false;
       let latestTimestampInBatch = null;
       if (comments.length > 0) {
           // Find the timestamp of the newest comment in the received batch
           latestTimestampInBatch = new Date(comments[0].timestamp).getTime(); // Assuming newest is first
           // If we have a previous timestamp, check if the newest in batch is newer
           if (lastCommentTimestamp && latestTimestampInBatch > lastCommentTimestamp) {
               newMessagesExist = true;
           }
           // Update the last known timestamp to the newest one from this batch
           lastCommentTimestamp = latestTimestampInBatch;
       }

       // Compare stringified content to avoid unnecessary DOM manipulation if content is identical
       if (JSON.stringify(comments) === JSON.stringify(lastComments)) {
           // console.log("No change in comments, skipping DOM update.");
           return; // Exit if comments haven't changed
       }

       // Play beep only if new messages arrived and chat is visible
       if (newMessagesExist && chatContainer.style.display !== 'none') {
           playBeep();
       }

       // *** Build HTML string for all comments ***
       let messagesHTML = '';
       if (comments.length === 0) {
           messagesHTML = '<div class="chat-message system-message">No messages yet.</div>';
       } else {
           comments.forEach(comment => {
               const messageDate = new Date(comment.timestamp);
               const timeString = messageDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
               const isAdminClass = comment.is_admin ? ' admin-message' : '';
               const deleteButtonHTML = isAdminMode ? `<button class="delete-comment-btn" data-comment-id="${comment.id}">❌</button>` : '';
               const imageHTML = comment.image_url ? `<br><a href="${comment.image_url}" target="_blank"><img src="${comment.image_url}" alt="User image" class="chat-image"></a>` : '';

               messagesHTML += `
                   <div class="chat-message${isAdminClass}" data-comment-id="${comment.id}">
                       <span class="timestamp">${timeString}</span>
                       <span class="message-text">${comment.text}</span>
                       ${imageHTML}
                       ${deleteButtonHTML}
                   </div>
               `;
           });
       }

       // *** Set innerHTML once ***
       // console.log("Setting innerHTML with:", messagesHTML);
       chatMessages.innerHTML = messagesHTML;

       // *** Add delete listeners AFTER setting innerHTML ***
       if (isAdminMode) {
           addDeleteButtonListeners();
       }

       lastComments = comments; // Update the cache
    }

    // --- Helper to add delete listeners ---
    function addDeleteButtonListeners() {
        document.querySelectorAll('.delete-comment-btn').forEach(button => {
            // Remove existing listener to prevent duplicates if re-rendering
            button.removeEventListener('click', handleDeleteComment);
            // Add the listener
            button.addEventListener('click', handleDeleteComment);
        });
    }

    // --- Handle Delete Comment ---
    function handleDeleteComment(event) {
        const commentId = event.target.getAttribute('data-comment-id');
        if (!commentId) return;

        if (confirm('Are you sure you want to delete this comment?')) {
            fetch(`/api/comments/${commentId}`, {
                method: 'DELETE',
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Remove the comment element from the DOM immediately
                    const commentElement = event.target.closest('.chat-message');
                    if (commentElement) {
                        commentElement.remove();
                    }
                    // Optionally, re-fetch comments if not using SSE to ensure consistency
                    if (!useSSE) {
                        fetchComments();
                    }
                } else {
                    alert('Error deleting comment: ' + (data.error || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error deleting comment:', error);
                alert('Error deleting comment. Please try again.');
            });
        }
    }

    // --- Play Beep ---
    function playBeep() {
        beepSound.play().catch(error => console.error("Error playing beep:", error));
    }

    // --- Handle Image Upload ---
    function uploadImage(file) {
        // Client-side validation (optional but good UX)
        const allowedTypes = ['image/png', 'image/jpeg', 'image/gif', 'image/webp'];
        if (!allowedTypes.includes(file.type)) {
            alert('Invalid file type. Please upload PNG, JPG, GIF, or WEBP.');
            return;
        }
        if (file.size > 5 * 1024 * 1024) { // 5MB limit
            alert('File is too large. Maximum size is 5MB.');
            return;
        }

        const formData = new FormData();
        formData.append('image', file);

        // Display temporary feedback (optional)
        imageUrlInput.value = 'Uploading...';
        imageUrlInput.disabled = true;

        fetch('/api/upload_image', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success && data.url) {
                imageUrlInput.value = data.url; // Set the URL in the input field
                // Optionally send the message automatically after upload
                // sendComment(); // <-- Keep this commented or uncomment based on desired UX
            } else {
                alert('Image upload failed: ' + (data.error || 'Unknown error'));
                imageUrlInput.value = ''; // Clear field on error
            }
        })
        .catch(error => {
            console.error('Error uploading image:', error);
            alert('Image upload failed. Please try again.');
            imageUrlInput.value = ''; // Clear field on error
        })
        .finally(() => {
             imageUrlInput.disabled = false; // Re-enable input
             // If not auto-sending, keep 'Uploading...' text until user clears/sends
             if (imageUrlInput.value === 'Uploading...') {
                 imageUrlInput.value = '';
             }
        });
    }

    // --- Send Comment ---
    function sendComment() {
      const text = messageInput.value.trim();
      const imageUrl = imageUrlInput.value.trim();

      if (!text && !imageUrl) {
        alert('Please enter a message or an image URL.');
        return;
      }

      sendButton.disabled = true; // Prevent double sending
      sendButton.textContent = 'Sending...';

      fetch('/api/comments', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ text: text, image_url: imageUrl }),
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          messageInput.value = ''; // Clear input fields
          imageUrlInput.value = '';
          // Fetch comments immediately ONLY if using polling
          if (!useSSE) {
              fetchComments();
          }
          // If using SSE, the update will arrive via the stream
        } else {
          alert('Error sending comment: ' + (data.error || 'Unknown error'));
        }
      })
      .catch(error => {
        console.error('Error sending comment:', error);
        alert('Error sending comment. Please try again.');
      })
      .finally(() => {
        sendButton.disabled = false;
        sendButton.textContent = 'Send';
      });
    }

    // --- Drag and Drop ---
    chatInputArea.addEventListener('dragover', (e) => {
        e.preventDefault(); // Prevent default behavior (opening file)
        e.stopPropagation();
        chatInputArea.classList.add('dragover'); // Add visual feedback class
    });

    chatInputArea.addEventListener('dragleave', (e) => {
        e.preventDefault();
        e.stopPropagation();
        chatInputArea.classList.remove('dragover'); // Remove visual feedback
    });

    chatInputArea.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        chatInputArea.classList.remove('dragover'); // Remove visual feedback

        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
            const file = e.dataTransfer.files[0]; // Handle the first dropped file
            uploadImage(file);
            e.dataTransfer.clearData(); // Clear drag data cache
        }
    });

    // --- Event Listeners ---
    sendButton.addEventListener('click', sendComment); // Add listener for send button

    // Add listener for Enter key in textarea
    messageInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) { // Send on Enter, allow Shift+Enter for newline
            e.preventDefault(); // Prevent default Enter behavior (newline)
            sendComment();
        }
    });

    // --- Initialize SSE Connection (Only if useSSE is true) ---
    let sseReconnectTimer = null;
    const SSE_MAX_LIFETIME = 15000; // 15 seconds
    const SSE_RECONNECT_DELAY = 1000; // 1 second
    let sseLastActivity = null;
    let enableSSEReconnect = false; // Set to true to enable periodic disconnect/reconnect

    function closeSSE() {
        if (eventSource) {
            eventSource.close();
            eventSource = null;
        }
        if (sseReconnectTimer) {
            clearTimeout(sseReconnectTimer);
            sseReconnectTimer = null;
        }
    }

    function scheduleSSEReconnect() {
        if (!enableSSEReconnect) return;
        if (sseReconnectTimer) clearTimeout(sseReconnectTimer);
        sseReconnectTimer = setTimeout(() => {
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
            setTimeout(() => {
                if (chatContainer.style.display !== 'none') {
                    initializeSSE();
                }
            }, SSE_RECONNECT_DELAY);
        }, SSE_MAX_LIFETIME);
    }

    function initializeSSE() {
        if (!useSSE || eventSource) {
            return;
        }
        if (chatContainer.style.display === 'none') {
            return;
        }
        eventSource = new EventSource('/api/comments/stream');
        sseLastActivity = Date.now();
        scheduleSSEReconnect();
        eventSource.onopen = function() {
            loadingIndicator.style.display = 'none';
            sseLastActivity = Date.now();
            scheduleSSEReconnect();
        };
        eventSource.onmessage = function(event) {
            try {
                const comments = JSON.parse(event.data);
                renderComments(comments);
            } catch (e) {
                console.error("Error parsing SSE data:", e);
            }
            sseLastActivity = Date.now();
            scheduleSSEReconnect();
        };
        eventSource.addEventListener('new_comment', function(event) {
            try {
                const comments = JSON.parse(event.data);
                renderComments(comments);
            } catch (e) {
                console.error("Error parsing SSE new_comment:", e);
            }
            sseLastActivity = Date.now();
            scheduleSSEReconnect();
        });
        eventSource.onerror = function(err) {
            loadingIndicator.textContent = 'Connection error. Retrying...';
            loadingIndicator.style.display = 'block';
            if (eventSource) eventSource.close();
            eventSource = null;
            if (sseReconnectTimer) clearTimeout(sseReconnectTimer);
            setTimeout(() => {
                if (chatContainer.style.display !== 'none') {
                    initializeSSE();
                }
            }, SSE_RECONNECT_DELAY);
        };
    }

    // --- Initial Load & Polling/SSE Start ---
    // Do NOT start polling or SSE until chat is made visible by the user.
    // (No polling or fetching on page load)
    // If chat starts hidden, SSE/Polling will be started by the toggle button.
    console.log("Chat will not poll or fetch until made visible by user.");

  });
</script>
</html>
