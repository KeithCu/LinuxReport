#!/usr/bin/env python3
"""
setup_gunicorn_multi_app.py

Automated deployment script for setting up Gunicorn services for multiple Flask applications.
Reads app configuration from deploy.py and generates:
- gunicorn.conf.py files (Unix Domain Sockets)
- /etc/conf.d/gunicorn-{appname} files (systemd configuration)
- Apache VirtualHost configuration files

Usage:
    sudo python3 setup_gunicorn_multi_app.py [--dry-run] [--start] [--skip-apache]
"""

import os
import sys
import shutil
import subprocess
import argparse
from datetime import datetime
from pathlib import Path
from urllib.parse import urlparse

# Import URLS from deploy.py
try:
    from deploy import URLS
except ImportError:
    print("Error: Could not import URLS from deploy.py")
    print("Make sure deploy.py is in the same directory as this script.")
    sys.exit(1)

# Configuration
SOCKET_DIR = "/run/gunicorn"
BASE_DIR = "/srv/http"
SYSTEMD_CONF_DIR = "/etc/conf.d"
APACHE_CONF_DIR = "/etc/httpd/conf/extra"
WSGI_CALLABLE = "app:application"  # Uses 'app' alias for compatibility
SHARED_VENV_APP = "LinuxReport2"
SHARED_VENV_DIR = Path(BASE_DIR) / SHARED_VENV_APP / "venv"
SHARED_VENV_BIN = SHARED_VENV_DIR / "bin"
GUNICORN_WORKERS = 1
GUNICORN_THREADS = 2

# Apps to exclude (handled on other servers)
EXCLUDED_APPS = {"technoreport"}


def extract_domain(url):
    """Extract domain name from URL."""
    parsed = urlparse(url)
    return parsed.netloc or parsed.path


def validate_app_directory(app_name):
    """Validate that the app directory exists and contains app.py."""
    app_dir = Path(BASE_DIR) / app_name
    if not app_dir.exists():
        return False, f"Directory {app_dir} does not exist"

    app_py = app_dir / "app.py"
    if not app_py.exists():
        return False, f"app.py not found in {app_dir}"

    return True, None


def log(message, level="INFO"):
    """Print a timestamped log message."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{timestamp}] {level}: {message}")


def validate_shared_venv():
    """Validate that the shared virtual environment exists."""
    if not SHARED_VENV_BIN.exists():
        return False, f"Shared virtualenv bin not found at {SHARED_VENV_BIN}"
    return True, None


def generate_gunicorn_config(app_name, socket_path):
    """Generate gunicorn.conf.py content."""
    config = f"""# gunicorn.conf.py for {app_name}
# Auto-generated by setup_gunicorn_multi_app.py

# Bind to Unix Domain Socket (faster than TCP, better security)
bind = "unix:{socket_path}"

# Worker configuration tuned for low-end hardware (adjust above if needed)
workers = {GUNICORN_WORKERS}
threads = {GUNICORN_THREADS}

# User/Group: Use the standard Arch web server user
user = "http"
group = "http"

# Timeout settings
timeout = 30
keepalive = 5

# Logging
accesslog = "-"  # Log to stdout (captured by systemd)
errorlog = "-"   # Log to stderr (captured by systemd)
loglevel = "info"

# Process naming
proc_name = "{app_name}"
"""
    return config


def generate_systemd_config(app_name, app_dir):
    """Generate systemd environment file content."""
    venv_path = SHARED_VENV_BIN
    gunicorn_config = Path(app_dir) / "gunicorn.conf.py"
    
    config = f"""# /etc/conf.d/gunicorn-{app_name}
# Auto-generated by setup_gunicorn_multi_app.py

# Path to the virtual environment's bin directory
VIRTUAL_ENV_PATH="{venv_path}"

# Gunicorn command options (points to config file and WSGI callable)
# WSGI callable: {WSGI_CALLABLE} (uses 'app' alias for compatibility)
GUNICORN_OPTS="--config {gunicorn_config} {WSGI_CALLABLE}"

# Set the working directory
WORKDIR="{app_dir}"
"""
    return config


def generate_apache_vhost(app_name, domain, app_dir, socket_path):
    """Generate Apache VirtualHost configuration."""
    # Extract base domain (remove www. if present)
    base_domain = domain.replace("www.", "")
    
    # Determine ServerAlias (add www. variant if not present)
    server_aliases = []
    if not domain.startswith("www."):
        server_aliases.append(f"www.{domain}")
    
    alias_directive = ""
    if server_aliases:
        alias_directive = f"    ServerAlias {' '.join(server_aliases)}\n"

    static_dir = Path(app_dir) / "static"
    
    vhost = f"""# Apache VirtualHost for {app_name}
# Auto-generated by setup_gunicorn_multi_app.py
# Domain: {domain}

<VirtualHost *:80>
    ServerName {domain}
{alias_directive}
    # 1. Alias: Handle static files directly (served by Apache for optimal performance)
    Alias /static/ {static_dir}/

    <Directory {static_dir}>
        Require all granted
        Options -Indexes
    </Directory>

    # 2. ProxyPass: Forward dynamic requests to Gunicorn via Unix socket
    ProxyPreserveHost On
    ProxyPass / unix:{socket_path}|http://localhost/
    ProxyPassReverse / unix:{socket_path}|http://localhost/

    # Logging
    ErrorLog /var/log/httpd/{app_name}_error.log
    CustomLog /var/log/httpd/{app_name}_access.log combined

    # Security headers (optional, can be configured globally)
    # Header always set X-Content-Type-Options "nosniff"
    # Header always set X-Frame-Options "SAMEORIGIN"
</VirtualHost>
"""
    return vhost


def backup_file(file_path):
    """Backup an existing file if it exists."""
    file_path = Path(file_path)
    if file_path.exists():
        backup_path = file_path.with_suffix(file_path.suffix + ".backup")
        shutil.copy2(file_path, backup_path)
        return backup_path
    return None


def write_file(file_path, content, dry_run=False):
    """Write content to file with backup."""
    if dry_run:
        print(f"  [DRY-RUN] Would write: {file_path}")
        print(f"  [DRY-RUN] Content preview (first 3 lines):")
        for i, line in enumerate(content.split('\n')[:3], 1):
            print(f"    {i}: {line}")
        return True
    
    try:
        # Create directory if it doesn't exist
        Path(file_path).parent.mkdir(parents=True, exist_ok=True)
        
        # Backup existing file
        backup = backup_file(file_path)
        if backup:
            log(f"Backed up existing file to: {backup}", "DEBUG")
        
        # Write new file
        with open(file_path, 'w') as f:
            f.write(content)
        
        log(f"Created file: {file_path}")
        return True
    except Exception as e:
        print(f"  Error writing {file_path}: {e}")
        return False


def setup_socket_directory(dry_run=False):
    """Create /run/gunicorn directory with proper permissions."""
    if dry_run:
        log(f"[DRY-RUN] Would create directory: {SOCKET_DIR}", "DEBUG")
        log(f"[DRY-RUN] Would set permissions: http:http, 0755", "DEBUG")
        return True
    
    try:
        Path(SOCKET_DIR).mkdir(parents=True, exist_ok=True)
        # Set ownership to http:http
        subprocess.run(["chown", "http:http", SOCKET_DIR], check=True)
        # Set permissions to 0755
        os.chmod(SOCKET_DIR, 0o755)
        log(f"Created directory: {SOCKET_DIR} (http:http, 0755)")
        return True
    except Exception as e:
        log(f"Error creating socket directory: {e}", "ERROR")
        return False


def enable_systemd_service(app_name, dry_run=False):
    """Enable systemd service for the app."""
    service_name = f"gunicorn@{app_name}.service"
    
    if dry_run:
        log(f"[DRY-RUN] Would enable service: {service_name}", "DEBUG")
        return True
    
    try:
        subprocess.run(["systemctl", "enable", service_name], check=True)
        log(f"Enabled service: {service_name}")
        return True
    except subprocess.CalledProcessError as e:
        log(f"Error enabling service {service_name}: {e}", "ERROR")
        return False


def start_systemd_service(app_name, dry_run=False):
    """Start systemd service for the app."""
    service_name = f"gunicorn@{app_name}.service"
    
    if dry_run:
        log(f"[DRY-RUN] Would start service: {service_name}", "DEBUG")
        return True
    
    try:
        subprocess.run(["systemctl", "start", service_name], check=True)
        log(f"Started service: {service_name}")
        return True
    except subprocess.CalledProcessError as e:
        log(f"Error starting service {service_name}: {e}", "ERROR")
        return False


def reload_systemd_daemon(dry_run=False):
    """Reload systemd daemon."""
    if dry_run:
        log("Would run systemctl daemon-reload (dry run)", "DEBUG")
        return True
    
    try:
        subprocess.run(["systemctl", "daemon-reload"], check=True)
        log("Reloaded systemd daemon")
        return True
    except subprocess.CalledProcessError as e:
        log(f"Error reloading systemd daemon: {e}", "ERROR")
        return False


def main():
    parser = argparse.ArgumentParser(
        description="Deploy Gunicorn services for multiple Flask applications",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Dry run to preview changes
  sudo python3 setup_gunicorn_multi_app.py --dry-run

  # Deploy all configs
  sudo python3 setup_gunicorn_multi_app.py

  # Deploy and start services
  sudo python3 setup_gunicorn_multi_app.py --start

  # Deploy without Apache configs
  sudo python3 setup_gunicorn_multi_app.py --skip-apache
        """
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Preview changes without making them"
    )
    parser.add_argument(
        "--start",
        action="store_true",
        help="Start systemd services after deployment"
    )
    parser.add_argument(
        "--skip-apache",
        action="store_true",
        help="Skip Apache VirtualHost configuration"
    )
    
    args = parser.parse_args()
    
    # Check if running as root
    if os.geteuid() != 0 and not args.dry_run:
        print("Error: This script must be run as root (use sudo)")
        sys.exit(1)
    
    # Filter out excluded apps
    apps_to_deploy = {
        app_name: url
        for app_name, url in URLS.items()
        if app_name.lower() not in EXCLUDED_APPS
    }
    
    if not apps_to_deploy:
        print("No apps to deploy (all apps excluded)")
        sys.exit(0)
    
    print("=" * 80)
    print("Gunicorn Multi-App Deployment Script")
    print("=" * 80)
    print(f"\nApps to deploy: {len(apps_to_deploy)}")
    for app_name, url in apps_to_deploy.items():
        print(f"  - {app_name} -> {url}")
    print()
    
    if args.dry_run:
        print("DRY-RUN MODE: No changes will be made\n")
    
    # Validate all app directories first
    print("Validating shared virtual environment...")
    shared_valid, shared_error = validate_shared_venv()
    if not shared_valid:
        print(f"  ❌ {shared_error}")
        print("\nError: Shared virtual environment missing")
        sys.exit(1)
    print(f"  ✅ Shared venv found at {SHARED_VENV_BIN}\n")

    print("Validating app directories...")
    validation_errors = []
    for app_name in apps_to_deploy.keys():
        is_valid, error = validate_app_directory(app_name)
        if not is_valid:
            validation_errors.append((app_name, error))
            print(f"  ❌ {app_name}: {error}")
        else:
            print(f"  ✅ {app_name}: Directory validated")
    
    if validation_errors:
        print(f"\nError: {len(validation_errors)} app(s) failed validation")
        print("Please fix the issues above before deploying.")
        sys.exit(1)
    
    print()
    
    # Setup socket directory
    print("Setting up socket directory...")
    if not setup_socket_directory(args.dry_run):
        print("Failed to setup socket directory")
        sys.exit(1)
    print()
    
    # Generate and write configs for each app
    success_count = 0
    failed_apps = []
    
    for app_name, url in apps_to_deploy.items():
        print(f"Processing {app_name}...")
        
        app_dir = Path(BASE_DIR) / app_name
        domain = extract_domain(url)
        socket_path = Path(SOCKET_DIR) / f"{app_name}.sock"

        # Generate gunicorn.conf.py
        gunicorn_config_path = app_dir / "gunicorn.conf.py"
        gunicorn_config_content = generate_gunicorn_config(app_name, socket_path)
        if not write_file(gunicorn_config_path, gunicorn_config_content, args.dry_run):
            failed_apps.append(app_name)
            continue

        # Generate systemd config
        systemd_config_path = Path(SYSTEMD_CONF_DIR) / f"gunicorn-{app_name}"
        systemd_config_content = generate_systemd_config(app_name, app_dir)
        if not write_file(systemd_config_path, systemd_config_content, args.dry_run):
            failed_apps.append(app_name)
            continue

        # Generate Apache VirtualHost (if not skipped)
        if not args.skip_apache:
            apache_config_path = Path(APACHE_CONF_DIR) / f"{app_name}.conf"
            apache_config_content = generate_apache_vhost(app_name, domain, app_dir, socket_path)
            if not write_file(apache_config_path, apache_config_content, args.dry_run):
                failed_apps.append(app_name)
                continue
        
        # Enable systemd service
        if not enable_systemd_service(app_name, args.dry_run):
            failed_apps.append(app_name)
            continue
        
        success_count += 1
        print(f"  ✅ {app_name} configured successfully\n")
    
    # Reload systemd daemon
    if success_count > 0:
        print("Reloading systemd daemon...")
        reload_systemd_daemon(args.dry_run)
        print()
    
    # Start services if requested
    if args.start and success_count > 0:
        print("Starting systemd services...")
        for app_name in apps_to_deploy.keys():
            if app_name not in failed_apps:
                start_systemd_service(app_name, args.dry_run)
        print()
    
    # Summary
    print("=" * 80)
    print("Deployment Summary")
    print("=" * 80)
    print(f"Successfully configured: {success_count}/{len(apps_to_deploy)}")
    if failed_apps:
        print(f"Failed apps: {', '.join(failed_apps)}")
    
    if args.dry_run:
        print("\nThis was a dry run. No changes were made.")
        print("Run without --dry-run to apply changes.")
    elif success_count == len(apps_to_deploy):
        print("\n✅ All apps configured successfully!")
        if not args.skip_apache:
            print("\nNext steps:")
            print("1. Review Apache VirtualHost configs in /etc/httpd/conf/extra/")
            print("2. Ensure Apache includes these configs (check /etc/httpd/conf/httpd.conf)")
            print("3. Restart Apache: sudo systemctl restart httpd")
            if not args.start:
                print("4. Start Gunicorn services: sudo systemctl start gunicorn@{appname}.service")
    else:
        print("\n⚠️  Some apps failed to configure. Please review errors above.")
        sys.exit(1)


if __name__ == "__main__":
    main()

